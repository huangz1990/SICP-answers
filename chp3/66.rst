练习 3.66
===========

这题可以这样来解：一直生成序对，直到遇到给定的序对为止（不包含给定的序对），然后计算已生成序对的数量。

为了达到生成序对并在合适的时候停止，需要一个 ``stream-take-while`` 函数：

.. literalinclude:: code/66-stream-take-while.scm

测试：

::

    1 ]=> (load "66-stream-take-while.scm")

    ;Loading "66-stream-take-while.scm"... done
    ;Value: stream-take-while

    1 ]=> (load "p228-integers.scm")

    ;Loading "p228-integers.scm"...
    ;  Loading "p228-add-streams.scm"... done
    ;  Loading "p228-ones.scm"... done
    ;... done
    ;Value: integers

    1 ]=> (stream->list                     
              (stream-take-while (lambda (x)  
                                     (< x 10))
                                 integers))

    ;Value 11: (1 2 3 4 5 6 7 8 9)

`stream->list <http://www.gnu.org/software/mit-scheme/documentation/mit-scheme-ref/Streams.html#Streams>`_ 可以将整个流转换成列表，作为一种方便的观察流的手段，非常有用。

计数 (1 100)
----------------

接着，载入 ``pairs`` ，对在 ``(1 100)`` 之前的序对进行计数：

::

    1 ]=> (load "p237-pairs.scm")

    ;Loading "p237-pairs.scm"...
    ;  Loading "p237-interleave.scm"... done
    ;... done
    ;Value: pairs

    1 ]=> (define before-1-100 (stream->list
                                   (stream-take-while
                                       (lambda (pair)
                                           (not (equal? pair '(1 100))))
                                       (pairs integers integers))))

    ;Value: before-1-100

    1 ]=> before-1-100

    ;Value 13: ((1 1) (1 2) (2 2) (1 3) (2 3) (1 4) (3 3) (1 5) (2 4) (1 6) (3 4) (1 7) (2 5) (1 8) (4 4) (1 9) (2 6) (1 10) (3 5) (1 11) (2 7) (1 12) (4 5) (1 13) (2 8) (1 14) (3 6) (1 15) (2 9) (1 16) (5 5) (1 17) (2 10) (1 18) (3 7) (1 19) (2 11) (1 20) (4 6) (1 21) (2 12) (1 22) (3 8) (1 23) (2 13) (1 24) (5 6) (1 25) (2 14) (1 26) (3 9) (1 27) (2 15) (1 28) (4 7) (1 29) (2 16) (1 30) (3 10) (1 31) (2 17) (1 32) (6 6) (1 33) (2 18) (1 34) (3 11) (1 35) (2 19) (1 36) (4 8) (1 37) (2 20) (1 38) (3 12) (1 39) (2 21) (1 40) (5 7) (1 41) (2 22) (1 42) (3 13) (1 43) (2 23) (1 44) (4 9) (1 45) (2 24) (1 46) (3 14) (1 47) (2 25) (1 48) (6 7) (1 49) (2 26) (1 50) (3 15) (1 51) (2 27) (1 52) (4 10) (1 53) (2 28) (1 54) (3 16) (1 55) (2 29) (1 56) (5 8) (1 57) (2 30) (1 58) (3 17) (1 59) (2 31) (1 60) (4 11) (1 61) (2 32) (1 62) (3 18) (1 63) (2 33) (1 64) (7 7) (1 65) (2 34) (1 66) (3 19) (1 67) (2 35) (1 68) (4 12) (1 69) (2 36) (1 70) (3 20) (1 71) (2 37) (1 72) (5 9) (1 73) (2 38) (1 74) (3 21) (1 75) (2 39) (1 76) (4 13) (1 77) (2 40) (1 78) (3 22) (1 79) (2 41) (1 80) (6 8) (1 81) (2 42) (1 82) (3 23) (1 83) (2 43) (1 84) (4 14) (1 85) (2 44) (1 86) (3 24) (1 87) (2 45) (1 88) (5 10) (1 89) (2 46) (1 90) (3 25) (1 91) (2 47) (1 92) (4 15) (1 93) (2 48) (1 94) (3 26) (1 95) (2 49) (1 96) (7 8) (1 97) (2 50) (1 98) (3 27) (1 99) (2 51))

    1 ]=> (length before-1-100)

    ;Value: 197

计数 (100 100) 
------------------

然后对 ``(100 100)`` 之前的序对进行计数：

::

    1 ]=> (define before-100-100 (stream->list 
                                     (stream-take-while
                                         (lambda (pair)
                                             (not (equal? pair '(100 100))))
                                         (pairs integers integers))))

    ;Aborting!: maximum recursion depth exceeded

非常可惜，解释器的递归深度不足以支持这个计算，看来这个序列一定非常大。

==========================================================================

::

    (1,1) | (1,2) | (1,3) | ...
    -----------------------------
          | (2,2) | (2,3) | ...
    -----------------------------  
          |       | (3,3) | ...
    -----------------------------
          |       |       | ...


这是一个递归的过程，我们记 :math:`S_i` 为从 :math:`(i,i+1)` 开始的那一行流，而把 :math:`P_i` 记作以 :math:`(i,i)` 开始的序对流，对于 :math:`(100,100)` 而言，它是 :math:`P_{100}` 的第一个元素，但现在要做的是找到它在 :math:`P_1` 中是第几个元素，为此我们可以慢慢回溯上去，首先来看看它在  :math:`P_{99}` 中是第几个元素。 :math:`P_{99}` 按照构造可以分为三个部分，分别是 :math:`(99,99)`， :math:`S_{99}` 和 :math:`P_{100}`，按照构造规则， :math:`(99,99)` 是第一个元素， :math:`(99,100)` 是第二个元素，而 :math:`(100,100)` 为第三个元素，原因是 :math:`(100，100)` 在 :math:`P_{100}` 中是第一个元素，因此它紧跟在 :math:`S_{99}` 的第一个元素之后，综上， :math:`(100，100)` 在 :math:`P_{99}` 中是第三个元素，这一过程可以一直上溯到 :math:`P_1` 为止，现在我们来找出一般的公式，假设 :math:`(100,100)` 在 :math:`P_{i+1}` 中是第 :math:`a_{i+1}` 个元素，那么它在 :math:`P_i` 中是第几个元素，显然首先 :math:`(i,i)` 为 :math:`P_i` 第一个元素，之后必须在 :math:`S_i` 中数够 :math:`a_{i+1}` 个元素后才刚好轮到  :math:`P_{i+1}` 中的第 :math:`a_{i+1}` 个元素，因此， :math:`(100,100)` 在 :math:`P_i` 中排在 :math:`2*a_{i+1}+1` 位， 即 :math:`a_i = 2 a_{i+1} + 1`，而 :math:`a_{100} = 1`，由此递推公式可得 :math:`a_1 = 1+2+2^2+2^3+\ldots+2^{99} = 2^{100} - 1`，如果问 :math:`(100,100)` 之前有多少个元素则把自己减去就行了，因此有 :math:`2^{100} - 2` 个元素。

其实到这里我们已经可以获得一般的公式了，分两种情形

- :math:`(i,i)`： 它排在第 :math:`2^{i} - 1` 位

- :math:`(i,j)`，:math:`j \neq i`： 则需要先向下看，得出 :math:`(i,j)` 在 :math:`P_i` 中的位置，由于其在 :math:`S_i` 中排在第 :math:`j-i` 位，因此，在 :math:`P_{i+1}` 中有 :math:`j-i-1` 个元素在其之前，因此它在 :math:`P_i` 中的位置是 :math:`2(j-i)`，再向上回溯，就得到其在整个流中的位置为 :math:`(j-i)2^{i}+2^{i-1}-1`

用上述第二个公式来检查 :math:`(1,100)` 的位置为198，故在其前面有197个元素。
